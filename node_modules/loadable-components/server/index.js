'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-disable react/no-danger */


exports.walkTree = walkTree;
exports.getLoadableState = getLoadableState;

var _react = require('react');

var _constants = require('../constants');

var _DeferredState = require('./DeferredState');

var _DeferredState2 = _interopRequireDefault(_DeferredState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Recurse a React Element tree, running visitor on each element.
// If visitor returns `false`, don't call the element's render function
// or recurse into its child elements
function walkTree(element, context, visitor) {
  var Component = element.type;
  // a stateless functional component or a class
  if (typeof Component === 'function') {
    var props = _extends({}, Component.defaultProps, element.props);
    var childContext = context;
    var child = void 0;

    // Are we are a react class?
    //   https://github.com/facebook/react/blob/master/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L66
    if (Component.prototype && Component.prototype.isReactComponent) {
      // typescript force casting since typescript doesn't have definitions for class
      // methods
      var instance = new Component(props, context);
      // In case the user doesn't pass these to super in the constructor
      instance.props = instance.props || props;
      instance.context = instance.context || context;

      // Override setState to just change the state, not queue up an update.
      //   (we can't do the default React thing as we aren't mounted "properly"
      //   however, we don't need to re-render as well only support setState in
      //   componentWillMount, which happens *before* render).
      instance.setState = function (nextState) {
        instance.state = _extends({}, instance.state, nextState);
      };

      // this is a poor man's version of
      //   https://github.com/facebook/react/blob/master/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L181
      if (instance.componentWillMount) {
        instance.componentWillMount();
      }

      if (instance.getChildContext) {
        childContext = _extends({}, context, instance.getChildContext());
      }

      if (visitor(element, instance, context) === false) {
        return;
      }

      child = instance.render();
    } else {
      // just a stateless functional
      if (visitor(element, null, context) === false) {
        return;
      }

      // typescript casting for stateless component
      child = Component(props, context);
    }

    if (child) {
      walkTree(child, childContext, visitor);
    }
  } else {
    // a basic string or dom element, just get children
    if (visitor(element, null, context) === false) {
      return;
    }

    if (element.props && element.props.children) {
      _react.Children.forEach(element.props.children, function (child) {
        if (child) {
          walkTree(child, context, visitor);
        }
      });
    }
  }
}

function getQueriesFromTree(_ref) {
  var rootElement = _ref.rootElement,
      _ref$rootContext = _ref.rootContext,
      rootContext = _ref$rootContext === undefined ? {} : _ref$rootContext;
  var fetchRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var queries = [];

  walkTree(rootElement, rootContext, function (element, instance, context) {
    var skipRoot = !fetchRoot && element === rootElement;

    if (instance && instance.constructor[_constants.LOADABLE] && !skipRoot) {
      var loadable = instance.constructor[_constants.LOADABLE]();
      var query = loadable.load().then(function () {
        return loadable.componentId;
      });

      if (query) {
        queries.push({ query: query, element: element, context: context });

        // Tell walkTree to not recurse inside this component;  we will
        // wait for the query to execute before attempting it.
        return false;
      }
    }

    return true;
  });

  return queries;
}

function getLoadableState(rootElement) {
  var rootContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var fetchRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  var queries = getQueriesFromTree({ rootElement: rootElement, rootContext: rootContext }, fetchRoot);

  // no queries found, nothing to do
  if (!queries.length) return Promise.resolve(new _DeferredState2.default([]));

  var errors = [];
  var componentIds = [];

  // wait on each query that we found, re-rendering the subtree when it's done
  var mappedQueries = queries.map(function (_ref2) {
    var query = _ref2.query,
        element = _ref2.element,
        context = _ref2.context;
    return (
      // we've just grabbed the query for element, so don't try and get it again
      query.then(function (componentId) {
        componentIds.push(componentId);
        return getLoadableState(element, context, false);
      }).then(function (state) {
        componentIds = [].concat(componentIds, state.componentIds);
      }).catch(function (e) {
        return errors.push(e);
      })
    );
  });

  return Promise.all(mappedQueries).then(function () {
    if (errors.length > 0) {
      var error = errors.length === 1 ? errors[0] : new Error(errors.length + ' errors were thrown when importing your modules.');
      error.queryErrors = errors;
      throw error;
    }

    return new _DeferredState2.default(componentIds);
  });
}